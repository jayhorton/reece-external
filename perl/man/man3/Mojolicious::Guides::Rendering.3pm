.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Rendering 3pm"
.TH Mojolicious::Guides::Rendering 3pm "2011-04-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Rendering \- Rendering
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Generating content with the Mojolicious renderer.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Essentials every Mojolicious developer should know.
.SS "Renderer"
.IX Subsection "Renderer"
The renderer is a tiny black box turning stash data into actual responses
utilizing multiple template systems and data encoding modules.
.PP
.Vb 3
\&  {text => \*(AqHello!\*(Aq}                 \-> 200 OK, text/html, \*(AqHello!\*(Aq
\&  {json => {x => 3}}                 \-> 200 OK, application/json, \*(Aq{"x":3}\*(Aq
\&  {text => \*(AqOops!\*(Aq, status => \*(Aq410\*(Aq} \-> 410 Gone, text/html, \*(AqOops!\*(Aq
.Ve
.PP
Templates can be automatically detected if enough information is provided by
the developer or routes.
Template names are expected to follow the \f(CW\*(C`name.format.handler\*(C'\fR scheme, with
\&\f(CW\*(C`name\*(C'\fR defaulting to \f(CW\*(C`controller/action\*(C'\fR or the route name, \f(CW\*(C`format\*(C'\fR
defaulting to \f(CW\*(C`html\*(C'\fR and \f(CW\*(C`handler\*(C'\fR to \f(CW\*(C`ep\*(C'\fR.
.PP
.Vb 3
\&  {controller => \*(Aqusers\*(Aq, action => \*(Aqlist\*(Aq} \-> \*(Aqusers/list.html.ep\*(Aq
\&  {name => \*(Aqfoo\*(Aq, format => \*(Aqtxt\*(Aq}          \-> \*(Aqfoo.txt.ep\*(Aq
\&  {name => \*(Aqfoo\*(Aq, handler => \*(Aqepl\*(Aq}         \-> \*(Aqfoo.html.epl\*(Aq
.Ve
.PP
All templates should be in the \f(CW\*(C`templates\*(C'\fR directory of the application
or the \f(CW\*(C`DATA\*(C'\fR section of the class \f(CW\*(C`main\*(C'\fR.
.PP
.Vb 6
\&  _\|_DATA_\|_
\&  @@ time.html.ep
\&  <!doctype html><html>
\&    <head><title>Time</title></head>
\&    <body><%= localtime time %></body>
\&  </html>
\&
\&  @@ hello.txt.ep
\&  ...
.Ve
.PP
The renderer can be easily extended to support additional template systems
with plugins, but more about that later.
.SS "Embedded Perl"
.IX Subsection "Embedded Perl"
Mojolicious includes a minimalistic but very powerful template system out
of the box called Embedded Perl or \f(CW\*(C`ep\*(C'\fR for short.
It allows the embedding of Perl code right into actual content using a small
set of special tags and line start characters.
.PP
.Vb 8
\&  <% Inline Perl %>
\&  <%= Perl expression, replaced with XML escaped result %>
\&  <%== Perl expression, replaced with raw result %>
\&  <%# Comment, useful for debugging %>
\&  % Perl line
\&  %= Perl expression line, replaced with XML escaped result
\&  %== Perl expression line, replaced with raw result
\&  %# Comment line, useful for debugging
.Ve
.PP
The simplest form is used to insert raw Perl code.
Tags and lines work pretty much the same, but depending on context one will
usually look a bit better.
.PP
.Vb 6
\&  <% my $i = 10; %>
\&  Text before.
\&  <% for my $j (1 .. $i) { %>
\&    <%= $j %>
\&  <% } %>
\&  Text after.
\&
\&  % my $i = 10;
\&  Text before.
\&  % for my $j (1 .. $i) {
\&    %= $j
\&  % }
\&  Text after.
.Ve
.PP
You can also insert results from actual Perl code using expressions, by
default the characters \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`\*(Aq\*(C'\fR and \f(CW\*(C`"\*(C'\fR will be
escaped to prevent \s-1XSS\s0 attacks against your application.
Semicolons get automatically appended to all expressions.
.PP
.Vb 2
\&  <%= \*(Aqlalala\*(Aq %>
\&  <%== \*(Aq<p>test</p>\*(Aq %>
.Ve
.PP
Only Mojo::ByteStream objects are excluded from automatic escaping.
.PP
.Vb 1
\&  <%= b(\*(Aq<p>test</p>\*(Aq) %>
.Ve
.PP
You can also add an additional equal sign to the end of a tag to have it
automatically remove all surrounding whitespace, this allows free indenting
without ruining the result.
.PP
.Vb 3
\&  <% for (1 .. 3) { %>
\&    <%= $foo =%>
\&  <% } %>
.Ve
.PP
Comment tags and lines are very useful to deactivate code for debugging
purposes.
.PP
.Vb 4
\&  % my $foo = \*(Aqlalala\*(Aq;
\&  <%# if ($foo) { %>
\&    <%= $foo =%>
\&  <%# } %>
.Ve
.PP
Stash values that don't have invalid characters in their name get
automatically initialized as normal variables in the template and the
controller instance as \f(CW$self\fR.
.PP
.Vb 2
\&  $r\->route(\*(Aq/foo/:name\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqtester\*(Aq);
\&
\&  Hello <%= $name %>.
.Ve
.PP
There are also many built in helper functions such as \f(CW\*(C`url_for\*(C'\fR, which
allows you to generate the \s-1URL\s0 of a specific route just from its name.
.PP
.Vb 1
\&  $r\->route(\*(Aq/foo/:name\*(Aq)\->to(\*(Aqfoo#bar\*(Aq)\->name(\*(Aqsome_route\*(Aq);
\&
\&  <%= url_for \*(Aqsome_route\*(Aq %>
.Ve
.SH "BASICS"
.IX Header "BASICS"
Most commonly used features every Mojolicious developer should know about.
.SS "Automatic Rendering"
.IX Subsection "Automatic Rendering"
The renderer can be manually started by calling the \f(CW\*(C`render\*(C'\fR controller
method, but thats usually not necessary, because it will get automatically
called if nothing has been rendered after the routes dispatcher finished its
work.
This also means you can have routes pointing only to templates without actual
actions.
.PP
.Vb 1
\&  $self\->render;
.Ve
.PP
There is one big difference though, by calling \f(CW\*(C`render\*(C'\fR manually you can
make sure that templates use the current controller instance and not the
default controller specified in the \f(CW\*(C`controller_class\*(C'\fR attribute of the
application class.
.ie n .SS "Rendering Templates (""template"")"
.el .SS "Rendering Templates (\f(CWtemplate\fP)"
.IX Subsection "Rendering Templates (template)"
The renderer will always try to detect the right template but you can also
use the \f(CW\*(C`template\*(C'\fR stash value to render a specific one.
.PP
.Vb 1
\&  $self\->render(template => \*(Aqfoo\*(Aq);
.Ve
.PP
Choosing a specific \f(CW\*(C`format\*(C'\fR and \f(CW\*(C`handler\*(C'\fR is just as easy.
.PP
.Vb 1
\&  $self\->render(template => \*(Aqfoo\*(Aq, format => \*(Aqtxt\*(Aq, handler => \*(Aqepl\*(Aq);
.Ve
.PP
Because rendering a specific template is the most common task it also has a
shortcut.
.PP
.Vb 1
\&  $self\->render(\*(Aqfoo\*(Aq);
.Ve
.PP
All values passed to the \f(CW\*(C`render\*(C'\fR call are only temporarily assigned to the
stash and get reset again once rendering is finished.
.ie n .SS "Rendering Inline Templates (""inline"")"
.el .SS "Rendering Inline Templates (\f(CWinline\fP)"
.IX Subsection "Rendering Inline Templates (inline)"
Some renderers such as \f(CW\*(C`ep\*(C'\fR allow templates to be passed inline.
.PP
.Vb 1
\&  $self\->render(inline => \*(AqThe result is <%= 1 + 1%>!\*(Aq);
.Ve
.PP
Since auto detection depends on a path you might have to supply a \f(CW\*(C`handler\*(C'\fR
too.
.PP
.Vb 1
\&  $self\->render(inline => "<%= shift\->param(\*(Aqfoo\*(Aq) %>", handler => \*(Aqepl\*(Aq);
.Ve
.ie n .SS "Rendering Text (""text"")"
.el .SS "Rendering Text (\f(CWtext\fP)"
.IX Subsection "Rendering Text (text)"
Perl characters can be rendered with the \f(CW\*(C`text\*(C'\fR stash value, the given
content will be automatically encoded to bytes.
.PP
.Vb 1
\&  $self\->render(text => \*(AqHello Wo\*:rld!\*(Aq);
.Ve
.ie n .SS "Rendering Data (""data"")"
.el .SS "Rendering Data (\f(CWdata\fP)"
.IX Subsection "Rendering Data (data)"
Raw bytes can be rendered with the \f(CW\*(C`data\*(C'\fR stash value, no encoding will be
performed.
.PP
.Vb 1
\&  $self\->render(data => $octets);
.Ve
.ie n .SS "Rendering \s-1JSON\s0 (""json"")"
.el .SS "Rendering \s-1JSON\s0 (\f(CWjson\fP)"
.IX Subsection "Rendering JSON (json)"
The \f(CW\*(C`json\*(C'\fR stash value allows you to pass Perl structures to the renderer
which get directly encoded to \s-1JSON\s0.
.PP
.Vb 1
\&  $self\->render(json => {foo => [1, \*(Aqtest\*(Aq, 3]});
.Ve
.ie n .SS "Partial Rendering (""partial"")"
.el .SS "Partial Rendering (\f(CWpartial\fP)"
.IX Subsection "Partial Rendering (partial)"
Sometimes you might want to access the rendered result, for example to
generate emails, this can be done using the \f(CW\*(C`partial\*(C'\fR stash value.
.PP
.Vb 1
\&  my $html = $self\->render(\*(Aqmail\*(Aq, partial => 1);
.Ve
.ie n .SS "Status Code (""status"")"
.el .SS "Status Code (\f(CWstatus\fP)"
.IX Subsection "Status Code (status)"
Response status codes can be changed with the \f(CW\*(C`status\*(C'\fR stash value.
.PP
.Vb 1
\&  $self\->render(text => \*(AqOops!\*(Aq, status => 500);
.Ve
.ie n .SS "Content Type (""format"")"
.el .SS "Content Type (\f(CWformat\fP)"
.IX Subsection "Content Type (format)"
The \f(CW\*(C`Content\-Type\*(C'\fR header of the response is actually based on the \s-1MIME\s0 type
mapping of the \f(CW\*(C`format\*(C'\fR stash value.
.PP
.Vb 1
\&  $self\->render(text => \*(AqHello!\*(Aq, format => \*(Aqtxt\*(Aq);
.Ve
.PP
These mappings can be easily extended or changed.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Add new MIME type
\&    $self\->types\->type(txt => \*(Aqtext/plain; charset=utf\-8\*(Aq);
\&  }
\&
\&  1;
.Ve
.SS "Stash Data"
.IX Subsection "Stash Data"
Data can be passed to templates through the \f(CW\*(C`stash\*(C'\fR in any of the native
Perl data types.
.PP
.Vb 3
\&  $self\->stash(author => \*(AqSebastian\*(Aq);
\&  $self\->stash(frameworks => [qw/Catalyst Mojolicious/]);
\&  $self\->stash(examples => {tweetylicious => \*(Aqa microblogging app\*(Aq});
\&
\&  <%= $author %>
\&  <%= $frameworks\->[1] %>
\&  <%= $examples\->{tweetylicious} %>
.Ve
.PP
Since everything is just Perl normal control structures just work.
.PP
.Vb 3
\&  <% for my $framework (@$frameworks) { %>
\&    <%= $framework %> was written by <%= $author %>.
\&  <% } %>
\&
\&  <% while (my ($app, $description) = each %$examples) { %>
\&    <%= $app %> is a <%= $description %>.
\&  <% } %>
.Ve
.SS "Helpers"
.IX Subsection "Helpers"
Helpers are little functions you can use in templates and controller code.
.PP
.Vb 1
\&  <%= dumper [1, 2, 3] %>
\&
\&  my $serialized = $self\->dumper([1, 2, 3]);
.Ve
.PP
The \f(CW\*(C`dumper\*(C'\fR helper for example will use Data::Dumper to serialize
whatever data structure you pass it, this can be very useful for debugging.
We differentiate between \f(CW\*(C`default helpers\*(C'\fR which are more general purpose
like \f(CW\*(C`dumper\*(C'\fR and \f(CW\*(C`tag helpers\*(C'\fR, which are template specific and mostly
used to generate \f(CW\*(C`HTML\*(C'\fR tags.
.PP
.Vb 1
\&  <%= javascript \*(Aq/script.js\*(Aq %>
\&
\&  <%= javascript begin %>
\&    var a = \*(Aqb\*(Aq;
\&  <% end %>
.Ve
.PP
The plugins Mojolicious::Plugin::DefaultHelpers and
Mojolicious::Plugin::TagHelpers contain all of them.
.SS "Layouts"
.IX Subsection "Layouts"
Most of the time when using \f(CW\*(C`ep\*(C'\fR templates you will want to wrap your
generated content in a \s-1HTML\s0 skeleton, thanks to layouts thats absolutely
trivial.
.PP
.Vb 3
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq;
\&  Hello World!
\&
\&  @@ layouts/mylayout.html.ep
\&  <!doctype html><html>
\&    <head><title>MyApp!</title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.PP
You just select the right layout template with the \f(CW\*(C`layout\*(C'\fR helper and place
the result of the current template with the \f(CW\*(C`content\*(C'\fR helper.
You can also pass along normal stash values to the \f(CW\*(C`layout\*(C'\fR helper.
.PP
.Vb 3
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq, title => \*(AqHi there!\*(Aq;
\&  Hello World!
\&
\&  @@ layouts/mylayout.html.ep
\&  <!doctype html><html>
\&    <head><title><%= $title %></title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Including Partial Templates"
.IX Subsection "Including Partial Templates"
Like most helpers the \f(CW\*(C`include\*(C'\fR helper is just a shortcut to make your life
a little easier.
.PP
.Vb 5
\&  @@ foo/bar.html.ep
\&  <!doctype html><html>
\&    <%= include \*(Aqheader\*(Aq %>
\&    <body>Bar!</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title>Howdy!</title></head>
.Ve
.PP
Instead of \f(CW\*(C`include\*(C'\fR you could also just call \f(CW\*(C`render\*(C'\fR with the \f(CW\*(C`partial\*(C'\fR
argument.
.PP
.Vb 5
\&  @@ foo/bar.html.ep
\&  <!doctype html><html>
\&    <%= $self\->render(\*(Aqheader\*(Aq, partial => 1) %>
\&    <body>Bar!</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title>Howdy!</title></head>
.Ve
.PP
Of course you can also pass stash values.
.PP
.Vb 5
\&  @@ foo/bar.html.ep
\&  <!doctype html><html>
\&    <%= include \*(Aqheader\*(Aq, title => \*(AqHello!\*(Aq %>
\&    <body>Bar!</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title><%= $title %></title></head>
.Ve
.SS "Reusable Template Blocks"
.IX Subsection "Reusable Template Blocks"
It's never fun to repeat yourself, thats why you can build reusable template
blocks in \f(CW\*(C`ep\*(C'\fR that work very similar normal Perl functions.
.PP
.Vb 6
\&  <% my $block = begin %>
\&    <% my $name = shift; %>
\&    Hello <%= $name %>.
\&  <% end %>
\&  <%= $block\->(\*(AqSebastian\*(Aq) %>
\&  <%= $block\->(\*(AqSara\*(Aq) %>
.Ve
.PP
Blocks are always delimited by the \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR keywords.
.PP
.Vb 7
\&  % my $block = begin
\&    % my $name = shift;
\&    Hello <%= $name %>.
\&  % end
\&  % for (1 .. 10) {
\&    %= $block\->(\*(AqSebastian\*(Aq)
\&  % }
.Ve
.PP
A naive translation to equivalent Perl code could look like this.
.PP
.Vb 11
\&  my $output = \*(Aq\*(Aq;
\&  my $block  = sub {
\&    my $name   = shift;
\&    my $output = \*(Aq\*(Aq;
\&    $output .= "Hello $name.";
\&    return $output;
\&  }
\&  for (1 .. 10) {
\&    $output .= $block\->(\*(AqSebastian\*(Aq);
\&  }
\&  print $output;
.Ve
.SS "Content Blocks"
.IX Subsection "Content Blocks"
Blocks and the \f(CW\*(C`content_for\*(C'\fR helper can also be used to pass whole sections
of the template to the layout.
.PP
.Vb 9
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq;
\&  <% content_for header => begin %>
\&    <title>MyApp!</title>
\&  <% end %>
\&  Hello World!
\&  <% content_for header => begin %>
\&    <meta http\-equiv="Pragma" content="no\-cache">
\&  <% end %>
\&
\&  @@ layouts/mylayout.html.ep
\&  <!doctype html><html>
\&    <head><%= content_for \*(Aqheader\*(Aq %></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Template Inheritance"
.IX Subsection "Template Inheritance"
Inheritance takes the layout concept above one step further.
Unlike \f(CW\*(C`content_for\*(C'\fR the \f(CW\*(C`content\*(C'\fR helper does not allow appending to
existing values, this makes it possible to overload whole template sections.
The only difference between \f(CW\*(C`layout\*(C'\fR and the \f(CW\*(C`extends\*(C'\fR is that extended
templates don't get prefixed with \f(CW\*(C`layouts/\*(C'\fR.
.PP
.Vb 10
\&  @@ first.html.ep
\&  %# "<div>First header!First footer!</div>"
\&  <div>
\&  <%= content header => begin %>
\&    First header!
\&  <% end %>
\&  <%= content footer => begin %>
\&    First footer!
\&  <% end %>
\&  </div>
\&
\&  @@ second.html.ep
\&  %# "<div>Second header!First footer!</div>"
\&  % extends \*(Aqfirst\*(Aq;
\&  <% content header => begin %>
\&    Second header!
\&  <% end %>
\&
\&  @@ third.html.ep
\&  %# "<div>Second header!Third footer!</div>"
\&  % extends \*(Aqsecond\*(Aq;
\&  <% content footer => begin %>
\&    Third footer!
\&  <% end %>
.Ve
.PP
This chain could go on and on to allow a very high level of template reuse.
.SS "Memorizing Template Blocks"
.IX Subsection "Memorizing Template Blocks"
Compiled templates are always cached in memory, but with the \f(CW\*(C`memorize\*(C'\fR
helper you can go one step further and prevent template blocks from being
executed more than once.
.PP
.Vb 3
\&  <%= memorize begin %>
\&    This template was compiled at <%= localtime time %>.
\&  <% end %>
.Ve
.ie n .SS "Mode Specific ""exception"" And ""not_found"" Templates"
.el .SS "Mode Specific \f(CWexception\fP And \f(CWnot_found\fP Templates"
.IX Subsection "Mode Specific exception And not_found Templates"
While the built in \f(CW\*(C`exception\*(C'\fR and \f(CW\*(C`not_found\*(C'\fR templates are very useful
during development, you most likely want to show your users something more
related to your application in production.
That's why Mojolicious will always try to render \f(CW\*(C`exception.$mode.html.*\*(C'\fR
or \f(CW\*(C`not_found.$mode.html.*\*(C'\fR before falling back to the built in default
templates.
.PP
.Vb 5
\&  @@ exception.production.html.ep
\&  <!doctype html><html>
\&    <head><title>Server Error</title></head>
\&    <body>Something bad happened!</body>
\&  </html>
\&
\&  @@ not_found.production.html.ep
\&  <!doctype html><html>
\&    <head><title>Page Not Found</title></head>
\&    <body>Page does not seem to exist.</body>
\&  </html>
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
Less commonly used and more powerful features.
.SS "Chunked Transfer Encoding"
.IX Subsection "Chunked Transfer Encoding"
For very dynamic content you might not know the response \f(CW\*(C`Content\-Length\*(C'\fR
in advance, thats where the \f(CW\*(C`chunked\*(C'\fR \f(CW\*(C`Transfer\-Encoding\*(C'\fR comes in handy.
A common use would be to send the \f(CW\*(C`head\*(C'\fR section of an \s-1HTML\s0 document to the
browser in advance and speed up preloading of referenced images and
stylesheets.
.PP
.Vb 7
\&  $self\->write_chunk(\*(Aq<html><head><title>Example</title>\*(Aq);
\&  $self\->write_chunk(\*(Aq<link href="example.css" rel="stylesheet"\*(Aq);
\&  $self\->write_chunk(\*(Aq type="text/css"></head>\*(Aq, sub {
\&    my $self = shift;
\&    $self\->write_chunk(\*(Aq<body>Example</body></html>\*(Aq);
\&    $self\->write_chunk(\*(Aq\*(Aq);
\&  });
.Ve
.PP
The optional drain callback ensures that all previous chunks have been
written before processing continues.
An empty chunk marks the end of the stream.
.PP
.Vb 9
\&  22
\&  <html><head><title>Example</title>
\&  29
\&  <link href="example.css" rel="stylesheet"
\&  17
\&   type="text/css"></head>
\&  1C
\&  <body>Example</body></html>
\&  0
.Ve
.PP
Especially in combination with long connection timeouts this can be very
useful for Comet (\f(CW\*(C`long polling\*(C'\fR).
Due to limitations in some web servers this might not work perfectly in all
deployment environments.
.SS "Encoding"
.IX Subsection "Encoding"
Templates stored in files are expected to be \f(CW\*(C`UTF\-8\*(C'\fR by default, but that
can be easily changed.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Different encoding
\&    $self\->renderer\->encoding(\*(Aqkoi8\-r\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
All templates from the \s-1DATA\s0 section are bound to the encoding of the Perl
script, so don't forget to use the utf8 pragma if necessary.
.SS "Base64 Encoded \s-1DATA\s0 Files"
.IX Subsection "Base64 Encoded DATA Files"
Base64 encoded static files such as images can be easily stored in the
\&\f(CW\*(C`DATA\*(C'\fR section of your application, similar to templates.
.PP
.Vb 2
\&  @@ favicon.ico (base64)
\&  ...base64 encoded image...
.Ve
.SS "Inflating \s-1DATA\s0 Templates"
.IX Subsection "Inflating DATA Templates"
Templates stored in files get preferred over files from the \f(CW\*(C`DATA\*(C'\fR section,
this allows you to include a default set of templates in your application
that the user can later customize.
The \f(CW\*(C`inflate\*(C'\fR command will write all templates and static files from the
\&\f(CW\*(C`DATA\*(C'\fR section into actual files in the \f(CW\*(C`templates\*(C'\fR and \f(CW\*(C`public\*(C'\fR
directories.
.PP
.Vb 2
\&  % ./myapp.pl inflate
\&  ...
.Ve
.SS "Customizing The Template Syntax"
.IX Subsection "Customizing The Template Syntax"
You can easily change the whole template syntax by loading the \f(CW\*(C`ep_renderer\*(C'\fR
plugin with a custom configuration.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin ep_renderer => {
\&    name     => \*(Aqmustache\*(Aq,
\&    template => {
\&      tag_start => \*(Aq{{\*(Aq,
\&      tag_end   => \*(Aq}}\*(Aq
\&    }
\&  };
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.mustache
\&  Hello {{= $name }}.
.Ve
.PP
Mojo::Template contains the whole list of available options.
.SS "Adding Helpers"
.IX Subsection "Adding Helpers"
Adding and redefining helpers is very easy, you can use them to do pretty
much everything.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  app\->helper(
\&    debug => sub {
\&      my ($self, $string) = @_;
\&      $self\->app\->log\->debug($string);
\&    }
\&  );
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&    $self\->debug(\*(Aqaction\*(Aq);
\&  } => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  % debug \*(Aqtemplate\*(Aq;
.Ve
.PP
Helpers can also accept template blocks as last argument, this for example
allows very pleasant to use tag helpers and filters.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::ByteStream;
\&
\&  app\->helper(
\&    trim_newline => sub {
\&      my ($self, $block) = @_;
\&      my $result = $block\->();
\&      $result =~ s/\en//g;
\&      return Mojo::ByteStream\->new($result);
\&    }
\&  );
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <%= trim_newline begin %>
\&    Some text.
\&    <%= 1 + 1 %>
\&    More text.
\&  <% end %>
.Ve
.PP
Wrapping the helper result into a Mojo::ByteStream object can prevent
accidental double escaping.
.SS "Adding Your Favorite Template System"
.IX Subsection "Adding Your Favorite Template System"
Maybe you would prefer a different template system than \f(CW\*(C`ep\*(C'\fR, all you have
to do is add a new \f(CW\*(C`handler\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  app\->renderer\->add_handler(
\&    mine => sub {
\&      my ($r, $c, $output, $options) = @_;
\&
\&      # One time use inline template
\&      my $inline = $options\->{inline};
\&
\&      # Generate relative template path
\&      my $name = $r\->template_name($options);
\&
\&      # Try to find appropriate template in DATA section
\&      my $content = $r\->get_inline_template($options, $name);
\&
\&      # Generate absolute template path
\&      my $path = $r\->template_path($options);
\&
\&      # This part is up to you and your template system :)
\&      ...
\&
\&      # Pass the rendered result back to the renderer
\&      $$output = \*(AqThe rendered result!\*(Aq;
\&    }
\&  );
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.mine
\&  ...
.Ve
.PP
Since most template systems don't support templates in the \f(CW\*(C`DATA\*(C'\fR section
the renderer provides methods to help you with that.
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
