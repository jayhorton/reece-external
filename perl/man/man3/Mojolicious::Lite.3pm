.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Lite 3pm"
.TH Mojolicious::Lite 3pm "2011-04-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Lite \- Micro Web Framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Using Mojolicious::Lite will enable "strict" and "warnings"
\&  use Mojolicious::Lite;
\&
\&  # Route with placeholder
\&  get \*(Aq/:foo\*(Aq => sub {
\&    my $self = shift;
\&    my $foo  = $self\->param(\*(Aqfoo\*(Aq);
\&    $self\->render(text => "Hello from $foo!");
\&  };
\&
\&  # Start the Mojolicious command system
\&  app\->start;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojolicious::Lite is a micro web framework built around Mojolicious.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
A quick example driven introduction to the wonders of Mojolicious::Lite.
Most of what you'll learn here also applies to normal Mojolicious
applications.
.SS "Hello World!"
.IX Subsection "Hello World!"
A minimal Hello World application looks like this, strict and warnings
are automatically enabled and a few functions imported when you use
Mojolicious::Lite, turning your script into a full featured web
application.
.PP
.Vb 1
\&  #!/usr/bin/env perl
\&
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/\*(Aq => sub { shift\->render(text => \*(AqHello World!\*(Aq) };
\&
\&  app\->start;
.Ve
.SS "Generator"
.IX Subsection "Generator"
There is also a helper command to generate a small example application.
.PP
.Vb 1
\&  % mojo generate lite_app
.Ve
.SS "Commands"
.IX Subsection "Commands"
All the normal Mojolicious command options are
available from the command line.
Note that \s-1CGI\s0, FastCGI and \s-1PSGI\s0 environments can usually be auto detected and
will just work without commands.
.PP
.Vb 2
\&  % ./myapp.pl daemon
\&  Server available at http://127.0.0.1:3000.
\&
\&  % ./myapp.pl daemon \-\-listen http://*:8080
\&  Server available at http://127.0.0.1:8080.
\&
\&  % ./myapp.pl cgi
\&  ...CGI output...
\&
\&  % ./myapp.pl fastcgi
\&  ...Blocking FastCGI main loop...
\&
\&  % ./myapp.pl
\&  ...List of available commands (or automatically detected environment)...
.Ve
.SS "Start"
.IX Subsection "Start"
The app\->start call that starts the Mojolicious command system can be
customized to override normal \f(CW@ARGV\fR use.
.PP
.Vb 1
\&  app\->start(\*(Aqcgi\*(Aq);
.Ve
.SS "Reloading"
.IX Subsection "Reloading"
Your application will automatically reload itself if you set the \f(CW\*(C`\-\-reload\*(C'\fR
option, so you don't have to restart the server after every change.
.PP
.Vb 2
\&  % ./myapp.pl daemon \-\-reload
\&  Server available at http://127.0.0.1:3000.
.Ve
.SS "Routes"
.IX Subsection "Routes"
Routes are basically just fancy paths that can contain different kinds of
placeholders.
\&\f(CW$self\fR is an instance of Mojolicious::Controller containing both the
\&\s-1HTTP\s0 request and response.
.PP
.Vb 5
\&  # /foo
\&  get \*(Aq/foo\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqHello World!\*(Aq);
\&  };
.Ve
.SS "Stash"
.IX Subsection "Stash"
The \f(CW\*(C`stash\*(C'\fR is used to pass data to templates, which can be inlined in the
\&\f(CW\*(C`DATA\*(C'\fR section.
.PP
.Vb 6
\&  # /bar
\&  get \*(Aq/bar\*(Aq => sub {
\&    my $self = shift;
\&    $self\->stash(one => 23);
\&    $self\->render(\*(Aqbaz\*(Aq, two => 24);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ baz.html.ep
\&  The magic numbers are <%= $one %> and <%= $two %>.
.Ve
.SS "\s-1HTTP\s0"
.IX Subsection "HTTP"
Mojo::Message::Request and Mojo::Message::Response give you full access
to all \s-1HTTP\s0 features and information.
.PP
.Vb 6
\&  # /agent
\&  get \*(Aq/agent\*(Aq => sub {
\&    my $self = shift;
\&    $self\->res\->headers\->header(\*(AqX\-Bender\*(Aq => \*(AqBite my shiny metal ass!\*(Aq);
\&    $self\->render(text => $self\->req\->headers\->user_agent);
\&  };
.Ve
.SS "Route Names"
.IX Subsection "Route Names"
All routes can have a name associated with them, this allows automatic
template detection and back referencing with \f(CW\*(C`url_for\*(C'\fR, \f(CW\*(C`link_to\*(C'\fR and
\&\f(CW\*(C`form_for\*(C'\fR.
Nameless routes get an automatically generated one assigned that is simply
equal to the route itself without non-word characters.
.PP
.Vb 2
\&  # /
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  # /hello
\&  get \*(Aq/hello\*(Aq;
\&
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <%= link_to Hello => \*(Aqhello\*(Aq %>.
\&  <%= link_to Reload => \*(Aqindex\*(Aq %>.
\&
\&  @@ hello.html.ep
\&  Hello World!
.Ve
.SS "Layouts"
.IX Subsection "Layouts"
Templates can have layouts.
.PP
.Vb 5
\&  # GET /with_layout
\&  get \*(Aq/with_layout\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(\*(Aqwith_layout\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ with_layout.html.ep
\&  % title \*(AqGreen!\*(Aq;
\&  % layout \*(Aqgreen\*(Aq;
\&  We\*(Aqve got content!
\&
\&  @@ layouts/green.html.ep
\&  <!doctype html><html>
\&    <head><title><%= title %></title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Blocks"
.IX Subsection "Blocks"
Template blocks can be used like normal Perl functions and are always
delimited by the \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR keywords.
.PP
.Vb 2
\&  # GET /with_block
\&  get \*(Aq/with_block\*(Aq => \*(Aqblock\*(Aq;
\&
\&  _\|_DATA_\|_
\&
\&  @@ block.html.ep
\&  <% my $link = begin %>
\&    <% my ($url, $name) = @_; %>
\&    Try <%= link_to $url => begin %><%= $name %><% end %>!
\&  <% end %>
\&  <!doctype html><html>
\&    <head><title>Sebastians Frameworks!</title></head>
\&    <body>
\&      <%== $link\->(\*(Aqhttp://mojolicio.us\*(Aq, \*(AqMojolicious\*(Aq) %>
\&      <%== $link\->(\*(Aqhttp://catalystframework.org\*(Aq, \*(AqCatalyst\*(Aq) %>
\&    </body>
\&  </html>
.Ve
.SS "Captured Content"
.IX Subsection "Captured Content"
The \f(CW\*(C`content_for\*(C'\fR helper can be used to pass around blocks of captured
content.
.PP
.Vb 5
\&  # GET /captured
\&  get \*(Aq/captured\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(\*(Aqcaptured\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ captured.html.ep
\&  % layout \*(Aqblue\*(Aq, title => \*(AqGreen!\*(Aq;
\&  <% content_for header => begin %>
\&    <meta http\-equiv="Pragma" content="no\-cache">
\&  <% end %>
\&  We\*(Aqve got content!
\&  <% content_for header => begin %>
\&    <meta http\-equiv="Expires" content="\-1">
\&  <% end %>
\&
\&  @@ layouts/blue.html.ep
\&  <!doctype html><html>
\&    <head>
\&      <title><%= title %></title>
\&      <%= content_for \*(Aqheader\*(Aq %>
\&    </head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Helpers"
.IX Subsection "Helpers"
You can also extend Mojolicious with your own helpers, a list of all built
in ones can be found in Mojolicious::Plugin::DefaultHelpers and
Mojolicious::Plugin::TagHelpers.
.PP
.Vb 7
\&  # "whois" helper
\&  app\->helper(whois => sub {
\&    my $self  = shift;
\&    my $agent = $self\->req\->headers\->user_agent || \*(AqAnonymous\*(Aq;
\&    my $ip    = $self\->tx\->remote_address;
\&    return "$agent ($ip)";
\&  });
\&
\&  # GET /secret
\&  get \*(Aq/secret\*(Aq => sub {
\&    my $self = shift;
\&    my $user = $self\->whois;
\&    $self\->app\->log\->debug("Request from $user.");
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ secret.html.ep
\&  We know who you are <%= whois %>.
.Ve
.SS "Placeholders"
.IX Subsection "Placeholders"
Route placeholders allow capturing parts of a request path until a \f(CW\*(C`/\*(C'\fR or
\&\f(CW\*(C`.\*(C'\fR separator occurs, results will be stored by name in the \f(CW\*(C`stash\*(C'\fR and
\&\f(CW\*(C`param\*(C'\fR.
.PP
.Vb 8
\&  # /foo/* (everything except "/" and ".")
\&  # /foo/test
\&  # /foo/test123
\&  get \*(Aq/foo/:bar\*(Aq => sub {
\&    my $self = shift;
\&    my $bar  = $self\->stash(\*(Aqbar\*(Aq);
\&    $self\->render(text => "Our :bar placeholder matched $bar");
\&  };
\&
\&  # /*something/foo (everything except "/" and ".")
\&  # /test/foo
\&  # /test123/foo
\&  get \*(Aq/(:bar)something/foo\*(Aq => sub {
\&    my $self = shift;
\&    my $bar  = $self\->param(\*(Aqbar\*(Aq);
\&    $self\->render(text => "Our :bar placeholder matched $bar");
\&  };
.Ve
.SS "Relaxed Placeholders"
.IX Subsection "Relaxed Placeholders"
Relaxed placeholders allow matching of everything until a \f(CW\*(C`/\*(C'\fR occurs.
.PP
.Vb 7
\&  # /*/hello (everything except "/")
\&  # /test/hello
\&  # /test123/hello
\&  # /test.123/hello
\&  get \*(Aq/(.you)/hello\*(Aq => sub {
\&    shift\->render(\*(Aqgroovy\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ groovy.html.ep
\&  Your name is <%= $you %>.
.Ve
.SS "Wildcard Placeholders"
.IX Subsection "Wildcard Placeholders"
Wildcard placeholders allow matching absolutely everything, including
\&\f(CW\*(C`/\*(C'\fR and \f(CW\*(C`.\*(C'\fR.
.PP
.Vb 7
\&  # /hello/* (everything)
\&  # /hello/test
\&  # /hello/test123
\&  # /hello/test.123/test/123
\&  get \*(Aq/hello/(*you)\*(Aq => sub {
\&    shift\->render(\*(Aqgroovy\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ groovy.html.ep
\&  Your name is <%= $you %>.
.Ve
.SS "\s-1HTTP\s0 Methods"
.IX Subsection "HTTP Methods"
Routes can be restricted to specific request methods.
.PP
.Vb 2
\&  # GET /bye
\&  get \*(Aq/bye\*(Aq => sub { shift\->render(text => \*(AqBye!\*(Aq) };
\&
\&  # POST /bye
\&  post \*(Aq/bye\*(Aq => sub { shift\->render(text => \*(AqBye!\*(Aq) };
\&
\&  # GET|POST|DELETE /bye
\&  any [qw/get post delete/] => \*(Aq/bye\*(Aq => sub {
\&    shift\->render(text => \*(AqBye!\*(Aq);
\&  };
\&
\&  # /baz
\&  any \*(Aq/baz\*(Aq => sub {
\&    my $self   = shift;
\&    my $method = $self\->req\->method;
\&    $self\->render(text => "You called /baz with $method");
\&  };
.Ve
.SS "Route Constraints"
.IX Subsection "Route Constraints"
All placeholders get compiled to a regex internally, with regex constraints
this process can be easily customized.
.PP
.Vb 6
\&  # /* (digits)
\&  any \*(Aq/:foo\*(Aq => [foo => qr/\ed+/] => sub {
\&    my $self = shift;
\&    my $foo  = $self\->param(\*(Aqfoo\*(Aq);
\&    $self\->render(text => "Our :foo placeholder matched $foo");
\&  };
\&
\&  # /* (everything else)
\&  any \*(Aq/:bar\*(Aq => [bar => qr/.*/] => sub {
\&    my $self = shift;
\&    my $bar  = $self\->param(\*(Aqbar\*(Aq);
\&    $self\->render(text => "Our :bar placeholder matched $bar");
\&  };
.Ve
.PP
Just make sure not to use \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR or capturing groups \f(CW\*(C`(...)\*(C'\fR, because
placeholders become part of a larger regular expression internally,
\&\f(CW\*(C`(?:...)\*(C'\fR is fine though.
.SS "Optional Placeholders"
.IX Subsection "Optional Placeholders"
Routes allow default values to make placeholders optional.
.PP
.Vb 5
\&  # /hello/*
\&  get \*(Aq/hello/:name\*(Aq => {name => \*(AqSebastian\*(Aq} => sub {
\&    my $self = shift;
\&    $self\->render(\*(Aqgroovy\*(Aq, format => \*(Aqtxt\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ groovy.txt.ep
\&  My name is <%= $name %>.
.Ve
.SS "A Little Bit Of Everything"
.IX Subsection "A Little Bit Of Everything"
All those features can be easily used together.
.PP
.Vb 4
\&  # /everything/*?name=*
\&  get \*(Aq/everything/:stuff\*(Aq => [stuff => qr/\ed+/] => {stuff => 23} => sub {
\&    shift\->render(\*(Aqwelcome\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ welcome.html.ep
\&  Stuff is <%= $stuff %>.
\&  Query param name is <%= param \*(Aqname\*(Aq %>.
.Ve
.PP
Here's a fully functional example for a html form handling application using
multiple features at once.
.PP
.Vb 1
\&  #!/usr/bin/env perl
\&
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  post \*(Aq/test\*(Aq => sub {
\&    my $self = shift;
\&
\&    my $groovy = $self\->param(\*(Aqgroovy\*(Aq) || \*(AqAustin Powers\*(Aq;
\&    $groovy =~ s/[^\ew\es]+//g;
\&
\&    $self\->render(
\&      template => \*(Aqwelcome\*(Aq,
\&      title    => \*(AqWelcome!\*(Aq,
\&      layout   => \*(Aqfunky\*(Aq,
\&      groovy   => $groovy
\&    );
\&  } => \*(Aqtest\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  % title \*(AqGroovy!\*(Aq;
\&  % layout \*(Aqfunky\*(Aq;
\&  Who is groovy?
\&  <%= form_for test => (method => \*(Aqpost\*(Aq) => begin %>
\&    <%= text_field \*(Aqgroovy\*(Aq %>
\&    <%= submit_button \*(AqWoosh!\*(Aq %>
\&  <% end %>
\&
\&  @@ welcome.html.ep
\&  <%= $groovy %> is groovy!
\&  <%= include \*(Aqmenu\*(Aq %>
\&
\&  @@ menu.html.ep
\&  <%= link_to index => begin %>
\&    Try again
\&  <% end %>
\&
\&  @@ layouts/funky.html.ep
\&  <!doctype html><html>
\&    <head><title><%= title %></title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Under"
.IX Subsection "Under"
Authentication and code shared between multiple routes can be realized easily
with the \f(CW\*(C`under\*(C'\fR statement.
All following routes are only evaluated if the \f(CW\*(C`under\*(C'\fR callback returned a
true value.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Authenticate based on name parameter
\&  under sub {
\&    my $self = shift;
\&
\&    # Authenticated
\&    my $name = $self\->param(\*(Aqname\*(Aq) || \*(Aq\*(Aq;
\&    return 1 if $name eq \*(AqBender\*(Aq;
\&
\&    # Not authenticated
\&    $self\->render(\*(Aqdenied\*(Aq);
\&    return;
\&  };
\&
\&  # GET / (with authentication)
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_;
\&
\&  @@ denied.html.ep
\&  You are not Bender, permission denied!
\&
\&  @@ index.html.ep
\&  Hi Bender!
.Ve
.PP
Prefixing multiple routes is another good use for \f(CW\*(C`under\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /foo
\&  under \*(Aq/foo\*(Aq;
\&
\&  # GET /foo/bar
\&  get \*(Aq/bar\*(Aq => sub { shift\->render(text => \*(Aqbar!\*(Aq) };
\&
\&  # GET /foo/baz
\&  get \*(Aq/baz\*(Aq => sub { shift\->render(text => \*(Aqbaz!\*(Aq) };
\&
\&  app\->start;
.Ve
.SS "Conditions"
.IX Subsection "Conditions"
Conditions such as \f(CW\*(C`agent\*(C'\fR allow even more powerful route constructs.
.PP
.Vb 4
\&  # /foo
\&  get \*(Aq/foo\*(Aq => (agent => qr/Firefox/) => sub {
\&    shift\->render(text => \*(AqCongratulations, you are using a cool browser!\*(Aq);
\&  };
\&
\&  # /foo
\&  get \*(Aq/foo\*(Aq => (agent => qr/Internet Explorer/) => sub {
\&    shift\->render(text => \*(AqDude, you really need to upgrade to Firefox!\*(Aq);
\&  };
.Ve
.SS "Formats"
.IX Subsection "Formats"
Formats can be automatically detected by looking at file extensions.
.PP
.Vb 6
\&  # /detection.html
\&  # /detection.txt
\&  get \*(Aq/detection\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(\*(Aqdetected\*(Aq);
\&  };
\&
\&  _\|_DATA_\|_
\&
\&  @@ detected.html.ep
\&  <!doctype html><html>
\&    <head><title>Detected!</title></head>
\&    <body>HTML was detected.</body>
\&  </html>
\&
\&  @@ detected.txt.ep
\&  TXT was detected.
.Ve
.SS "Sessions"
.IX Subsection "Sessions"
Signed cookie based sessions just work out of the box as soon as you start
using them.
The \f(CW\*(C`flash\*(C'\fR can be used to store values that will only be available for the
next request (unlike \f(CW\*(C`stash\*(C'\fR, which is only available for the current
request), this is very useful in combination with \f(CW\*(C`redirect_to\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/login\*(Aq => sub {
\&    my $self = shift;
\&    my $name = $self\->param(\*(Aqname\*(Aq) || \*(Aq\*(Aq;
\&    my $pass = $self\->param(\*(Aqpass\*(Aq) || \*(Aq\*(Aq;
\&    return $self\->render unless $name eq \*(Aqsebastian\*(Aq && $pass eq \*(Aq1234\*(Aq;
\&    $self\->session(name => $name);
\&    $self\->flash(message => \*(AqThanks for logging in!\*(Aq);
\&    $self\->redirect_to(\*(Aqindex\*(Aq);
\&  } => \*(Aqlogin\*(Aq;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&    return $self\->redirect_to(\*(Aqlogin\*(Aq) unless $self\->session(\*(Aqname\*(Aq);
\&    $self\->render;
\&  } => \*(Aqindex\*(Aq;
\&
\&  get \*(Aq/logout\*(Aq => sub {
\&    my $self = shift;
\&    $self\->session(expires => 1);
\&    $self\->redirect_to(\*(Aqindex\*(Aq);
\&  } => \*(Aqlogout\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ layouts/default.html.ep
\&  <!doctype html><html>
\&    <head><title><%= title %></title></head>
\&    <body><%= content %></body>
\&  </html>
\&
\&  @@ login.html.ep
\&  % layout \*(Aqdefault\*(Aq;
\&  % title \*(AqLogin\*(Aq;
\&  <%= form_for login => begin %>
\&    <% if (param \*(Aqname\*(Aq) { %>
\&      <b>Wrong name or password, please try again.</b><br>
\&    <% } %>
\&    Name:<br>
\&    <%= text_field \*(Aqname\*(Aq %><br>
\&    Password:<br>
\&    <%= password_field \*(Aqpass\*(Aq %><br>
\&    <%= submit_button \*(AqLogin\*(Aq %>
\&  <% end %>
\&
\&  @@ index.html.ep
\&  % layout \*(Aqdefault\*(Aq;
\&  % title \*(AqWelcome\*(Aq;
\&  <% if (my $message = flash \*(Aqmessage\*(Aq ) { %>
\&    <b><%= $message %></b><br>
\&  <% } %>
\&  Welcome <%= session \*(Aqname\*(Aq %>!<br>
\&  <%= link_to logout => begin %>
\&    Logout
\&  <% end %>
.Ve
.SS "Secret"
.IX Subsection "Secret"
Note that you should use a custom \f(CW\*(C`secret\*(C'\fR to make signed cookies really secure.
.PP
.Vb 1
\&  app\->secret(\*(AqMy secret passphrase here!\*(Aq);
.Ve
.SS "User Agent"
.IX Subsection "User Agent"
A full featured \s-1HTTP\s0 1.1 and WebSocket user agent is built right in.
Especially in combination with Mojo::JSON and Mojo::DOM this can be a
very powerful tool.
.PP
.Vb 4
\&  get \*(Aq/test\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(data => $self\->ua\->get(\*(Aqhttp://mojolicio.us\*(Aq)\->res\->body);
\&  };
.Ve
.SS "WebSockets"
.IX Subsection "WebSockets"
WebSocket applications have never been this easy before.
.PP
.Vb 7
\&  websocket \*(Aq/echo\*(Aq => sub {
\&    my $self = shift;
\&    $self\->on_message(sub {
\&      my ($self, $message) = @_;
\&      $self\->send_message("echo: $message");
\&    });
\&  };
.Ve
.SS "External Templates"
.IX Subsection "External Templates"
External templates will be searched by the renderer in a \f(CW\*(C`templates\*(C'\fR
directory.
.PP
.Vb 3
\&  # /external
\&  any \*(Aq/external\*(Aq => sub {
\&    my $self = shift;
\&
\&    # templates/foo/bar.html.ep
\&    $self\->render(\*(Aqfoo/bar\*(Aq);
\&  };
.Ve
.SS "Static Files"
.IX Subsection "Static Files"
Static files will be automatically served from the \f(CW\*(C`DATA\*(C'\fR section
(even Base 64 encoded) or a \f(CW\*(C`public\*(C'\fR directory if it exists.
.PP
.Vb 2
\&  @@ something.js
\&  alert(\*(Aqhello!\*(Aq);
\&
\&  @@ test.txt (base64)
\&  dGVzdCAxMjMKbGFsYWxh
\&
\&  % mkdir public
\&  % mv something.js public/something.js
.Ve
.SS "Testing"
.IX Subsection "Testing"
Testing your application is as easy as creating a \f(CW\*(C`t\*(C'\fR directory and filling
it with normal Perl unit tests.
.PP
.Vb 2
\&  use Test::More tests => 3;
\&  use Test::Mojo;
\&
\&  use FindBin;
\&  require "$FindBin::Bin/../myapp.pl";
\&
\&  my $t = Test::Mojo\->new;
\&  $t\->get_ok(\*(Aq/\*(Aq)\->status_is(200)\->content_like(qr/Funky!/);
.Ve
.PP
Run all unit tests with the \f(CW\*(C`test\*(C'\fR command.
.PP
.Vb 1
\&  % ./myapp.pl test
.Ve
.PP
To make your tests more noisy and show you all log messages you can also
change the application log level directly in your test files.
.PP
.Vb 1
\&  $t\->app\->log\->level(\*(Aqdebug\*(Aq);
.Ve
.SS "Mode"
.IX Subsection "Mode"
To disable debug messages later in a production setup you can change the
Mojolicious mode, default will be \f(CW\*(C`development\*(C'\fR.
.PP
.Vb 1
\&  % ./myapp.pl \-\-mode production
.Ve
.SS "Logging"
.IX Subsection "Logging"
Log messages will be automatically written to a \f(CW\*(C`log/$mode.log\*(C'\fR file if a
\&\f(CW\*(C`log\*(C'\fR directory exists.
.PP
.Vb 1
\&  % mkdir log
.Ve
.PP
For more control the Mojolicious instance can be accessed directly.
.PP
.Vb 5
\&  app\->log\->level(\*(Aqerror\*(Aq);
\&  app\->routes\->route(\*(Aq/foo/:bar\*(Aq)\->via(\*(Aqget\*(Aq)\->to(cb => sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqHello Mojo!\*(Aq);
\&  });
.Ve
.SS "Growing"
.IX Subsection "Growing"
In case a lite app needs to grow, lite and real Mojolicious applications
can be easily mixed to make the transition process very smooth.
.PP
.Vb 2
\&  package MyApp::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  sub index { shift\->render(text => \*(AqIt works!\*(Aq) }
\&
\&  package main;
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/bar\*(Aq => sub { shift\->render(text => \*(AqThis too!\*(Aq) };
\&
\&  app\->routes\->namespace(\*(AqMyApp\*(Aq);
\&  app\->routes\->route(\*(Aq/foo/:action\*(Aq)\->via(\*(Aqget\*(Aq)\->to(\*(Aqfoo#index\*(Aq);
\&
\&  app\->start;
.Ve
.PP
There is also a helper command to generate a full Mojolicious example that
will let you explore the astonishing similarities between
Mojolicious::Lite and Mojolicious applications.
Both share about 99% of the same code, so almost everything you learned in
this tutorial applies there too. :)
.PP
.Vb 1
\&  % mojo generate app
.Ve
.SS "More"
.IX Subsection "More"
You can continue with Mojolicious::Guides now, and don't forget to have
fun!
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mojolicious::Lite implements the following functions.
.ie n .SS """any"""
.el .SS "\f(CWany\fP"
.IX Subsection "any"
.Vb 2
\&  my $route = any \*(Aq/:foo\*(Aq => sub {...};
\&  my $route = any [qw/get post/] => \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching any of the listed \s-1HTTP\s0 request methods or all.
See also the tutorial above for more argument variations.
.ie n .SS """app"""
.el .SS "\f(CWapp\fP"
.IX Subsection "app"
.Vb 1
\&  my $app = app;
.Ve
.PP
The Mojolicious::Lite application.
.ie n .SS """del"""
.el .SS "\f(CWdel\fP"
.IX Subsection "del"
.Vb 1
\&  my $route = del \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching only \f(CW\*(C`DELETE\*(C'\fR requests.
See also the tutorial above for more argument variations.
.ie n .SS """get"""
.el .SS "\f(CWget\fP"
.IX Subsection "get"
.Vb 1
\&  my $route = get \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching only \f(CW\*(C`GET\*(C'\fR requests.
See also the tutorial above for more argument variations.
.ie n .SS """plugin"""
.el .SS "\f(CWplugin\fP"
.IX Subsection "plugin"
.Vb 6
\&  plugin \*(Aqsomething\*(Aq;
\&  plugin \*(Aqsomething\*(Aq, foo => 23;
\&  plugin \*(Aqsomething\*(Aq, {foo => 23};
\&  plugin \*(AqFoo::Bar\*(Aq;
\&  plugin \*(AqFoo::Bar\*(Aq, foo => 23;
\&  plugin \*(AqFoo::Bar\*(Aq, {foo => 23};
.Ve
.PP
Load a plugin.
.ie n .SS """post"""
.el .SS "\f(CWpost\fP"
.IX Subsection "post"
.Vb 1
\&  my $route = post \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching only \f(CW\*(C`POST\*(C'\fR requests.
See also the tutorial above for more argument variations.
.ie n .SS """put"""
.el .SS "\f(CWput\fP"
.IX Subsection "put"
.Vb 1
\&  my $route = put \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching only \f(CW\*(C`PUT\*(C'\fR requests.
See also the tutorial above for more argument variations.
.ie n .SS """under"""
.el .SS "\f(CWunder\fP"
.IX Subsection "under"
.Vb 2
\&  my $route = under sub {...};
\&  my $route = under \*(Aq/:foo\*(Aq;
.Ve
.PP
Generate bridge to which all following routes are automatically appended.
See also the tutorial above for more argument variations.
.ie n .SS """websocket"""
.el .SS "\f(CWwebsocket\fP"
.IX Subsection "websocket"
.Vb 1
\&  my $route = websocket \*(Aq/:foo\*(Aq => sub {...};
.Ve
.PP
Generate route matching only \f(CW\*(C`WebSocket\*(C'\fR handshakes.
See also the tutorial above for more argument variations.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojolicious::Lite inherits all attributes from Mojolicious.
.SH "METHODS"
.IX Header "METHODS"
Mojolicious::Lite inherits all methods from Mojolicious.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
