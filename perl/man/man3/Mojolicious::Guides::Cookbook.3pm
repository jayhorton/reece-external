.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Cookbook 3pm"
.TH Mojolicious::Guides::Cookbook 3pm "2011-04-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Cookbook \- Cookbook
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Cooking with Mojolicious, recipes for every taste.
.SH "DEPLOYMENT"
.IX Header "DEPLOYMENT"
Getting Mojolicious and Mojolicious::Lite applications running on
different platforms.
.SS "Builtin Server"
.IX Subsection "Builtin Server"
Mojolicious contains a very portable \s-1HTTP\s0 1.1 compliant web server.
It is usually used during development but is solid and fast enough for small
to mid sized applications.
.PP
.Vb 2
\&  % ./script/myapp daemon
\&  Server available at http://127.0.0.1:3000.
.Ve
.PP
It has many configuration options and is known to work on every platform
Perl works on.
.PP
.Vb 2
\&  % ./script/myapp help daemon
\&  ...List of available options...
.Ve
.PP
Another huge advantage is that it supports \s-1TLS\s0 and WebSockets out of the box.
.PP
.Vb 2
\&  % ./script/myapp daemon \-\-listen https://*:3000
\&  Server available at https://127.0.0.1:3000.
.Ve
.PP
A development certificate for testing purposes is built right in, so it just
works.
.SS "Hypnotoad"
.IX Subsection "Hypnotoad"
For bigger applications Mojolicious contains the \s-1UNIX\s0 optimized preforking
web server Mojo::Server::Hypnotoad that will allow you to take advantage
of multiple cpu cores and copy-on-write.
.PP
.Vb 5
\&  Mojo::Server::Hypnotoad
\&  |\- Mojo::Server::Daemon [1]
\&  |\- Mojo::Server::Daemon [2]
\&  |\- Mojo::Server::Daemon [3]
\&  \`\- Mojo::Server::Daemon [4]
.Ve
.PP
It is based on the normal builtin web server but optimized specifically for
production environments out of the box.
.PP
.Vb 2
\&  % hypnotoad script/myapp
\&  Server available at http://127.0.0.1:8080.
.Ve
.PP
Config files are plain Perl scripts for maximal customizability.
.PP
.Vb 2
\&  # hypnotoad.conf
\&  {listen => [\*(Aqhttp://*:80\*(Aq], workers => 10};
.Ve
.PP
But one of its biggest advantages is the support for effortless zero downtime
software upgrades.
That means you can upgrade Mojolicious, Perl or even system libraries at
runtime without ever stopping the server or losing a single incoming
connection, just by sending it a \f(CW\*(C`USR2\*(C'\fR signal.
.PP
.Vb 1
\&  % kill \-s \*(AqUSR2\*(Aq \`cat hypnotoad.pid\`
.Ve
.SS "Nginx"
.IX Subsection "Nginx"
One of the most popular setups these days is the builtin web server behind a
Nginx reverse proxy.
.PP
.Vb 10
\&  upstream myapp {
\&    server 127.0.0.1:8080;
\&  }
\&  server {
\&    listen 80;
\&    server_name localhost;
\&    location / {
\&      proxy_read_timeout 300;
\&      proxy_pass http://myapp;
\&      proxy_set_header Host $http_host;
\&      proxy_set_header X\-Forwarded\-For $proxy_add_x_forwarded_for;
\&    }
\&  }
.Ve
.PP
You might also want to enable reverse proxy support in \f(CW\*(C`hypnotoad\*(C'\fR.
This allows Mojolicious to automatically pick up the \f(CW\*(C`X\-Forwarded\-For\*(C'\fR,
\&\f(CW\*(C`X\-Forwarded\-Host\*(C'\fR and \f(CW\*(C`X\-Forwarded\-HTTPS\*(C'\fR headers.
.PP
.Vb 2
\&  # hypnotoad.conf
\&  {proxy => 1};
.Ve
.SS "Apache/CGI"
.IX Subsection "Apache/CGI"
\&\f(CW\*(C`CGI\*(C'\fR is supported out of the box and your Mojolicious application will
automatically detect that it is executed as a \f(CW\*(C`CGI\*(C'\fR script.
.PP
.Vb 1
\&  ScriptAlias / /home/sri/myapp/script/myapp/
.Ve
.SS "Apache/FastCGI"
.IX Subsection "Apache/FastCGI"
\&\f(CW\*(C`FastCGI\*(C'\fR is also supported out of the box and your Mojolicious
application will automatically detect that it is executed as a \f(CW\*(C`FastCGI\*(C'\fR
script.
.PP
.Vb 3
\&  FastCgiIpcDir /home/sri/myapp
\&  FastCgiServer /home/sri/myapp/script/myapp \-processes 1
\&  Alias / /home/sri/myapp/script/myapp/
.Ve
.SS "PSGI/Plack"
.IX Subsection "PSGI/Plack"
\&\s-1PSGI\s0 is an interface between Perl web frameworks and web servers, and
Plack is a Perl module and toolkit that contains \s-1PSGI\s0 middleware, helpers
and adapters to web servers.
\&\s-1PSGI\s0 and Plack are inspired by Python's \s-1WSGI\s0 and Ruby's Rack.
Mojolicious applications are ridiculously simple to deploy with Plack.
.PP
.Vb 2
\&  % plackup ./script/myapp
\&  HTTP::Server::PSGI: Accepting connections at http://0:5000/
.Ve
.PP
Plack provides many server and protocol adapters for you to choose from
such as \f(CW\*(C`FCGI\*(C'\fR, \f(CW\*(C`SCGI\*(C'\fR and \f(CW\*(C`mod_perl\*(C'\fR.
Make sure to run \f(CW\*(C`plackup\*(C'\fR from your applications home directory, otherwise
libraries might not be found.
.PP
.Vb 1
\&  % plackup ./script/myapp \-s FCGI \-l /tmp/myapp.sock
.Ve
.PP
Because \f(CW\*(C`plackup\*(C'\fR uses a weird trick to load your script, Mojolicious is
not always able to detect the applications home directory, if thats the case
you can simply use the \f(CW\*(C`MOJO_HOME\*(C'\fR environment variable.
Also note that \f(CW\*(C`app\->start\*(C'\fR needs to be the last Perl statement in the
application script for the same reason.
.PP
.Vb 2
\&  % MOJO_HOME=/home/sri/myapp plackup ./script/myapp
\&  HTTP::Server::PSGI: Accepting connections at http://0:5000/
.Ve
.PP
Some server adapters might ask for a \f(CW\*(C`.psgi\*(C'\fR file, if thats the case you can
just point them at your application script because it will automatically
act like one if it detects the presence of a \f(CW\*(C`PLACK_ENV\*(C'\fR environment
variable.
.SS "Apache/mod_perl (PSGI/Plack)"
.IX Subsection "Apache/mod_perl (PSGI/Plack)"
\&\f(CW\*(C`mod_perl\*(C'\fR is a good example for a \s-1PSGI\s0 adapter that is used without
\&\f(CW\*(C`plackup\*(C'\fR, note that setting the \f(CW\*(C`PLACK_ENV\*(C'\fR environment variable is
required for Mojolicious \s-1PSGI\s0 detection.
.PP
.Vb 3
\&  <VirtualHost *:80>
\&    ServerName localhost
\&    DocumentRoot /home/sri/myapp/public
\&
\&    <Perl>
\&      $ENV{PLACK_ENV} = \*(Aqproduction\*(Aq;
\&      $ENV{MOJO_HOME} = \*(Aq/home/sri/myapp\*(Aq;
\&    </Perl>
\&
\&    <Location /myapp>
\&      SetHandler perl\-script
\&      PerlHandler Plack::Handler::Apache2
\&      PerlSetVar psgi_app /home/sri/myapp/script/myapp
\&    </Location>
\&  </VirtualHost>
.Ve
.SS "Rewriting"
.IX Subsection "Rewriting"
Sometimes you might have to deploy your application in a blackbox environment
where you can't just change the server configuration or behind a reverse
proxy that passes along additional information with \f(CW\*(C`X\-*\*(C'\fR headers.
In such cases you can use a \f(CW\*(C`before_dispatch\*(C'\fR hook to rewrite incoming
requests.
.PP
.Vb 5
\&  app\->hook(before_dispatch => sub {
\&    my $self = shift;
\&    $self\->req\->url\->base\->scheme(\*(Aqhttps\*(Aq)
\&      if $self\->req\->headers\->header(\*(AqX\-Forwarded\-Protocol\*(Aq) eq \*(Aqhttps\*(Aq;
\&  });
.Ve
.SS "Embedding"
.IX Subsection "Embedding"
You can also use the builtin web server to embed Mojolicious applications
into alien environments like foreign event loops.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::Server::Daemon;
\&
\&  # Normal action
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&    $self\->render(text => \*(AqHello World!\*(Aq);
\&  };
\&
\&  # Connect application with custom daemon
\&  my $daemon =
\&    Mojo::Server::Daemon\->new(app => app, listen => [\*(Aqhttp://*:8080\*(Aq]);
\&  $daemon\->prepare_ioloop;
\&
\&  # Call "one_tick" repeatedly from the alien environment
\&  $daemon\->ioloop\->one_tick while 1;
.Ve
.SH "USER AGENT"
.IX Header "USER AGENT"
When we say Mojolicious is a web framework we actually mean it.
.SS "Web Scraping"
.IX Subsection "Web Scraping"
Scraping information from web sites has never been this much fun before.
The built in \s-1XML/HTML5\s0 parser Mojo::DOM supports all \s-1CSS3\s0 selectors that
make sense for a standalone parser.
.PP
.Vb 3
\&  # Fetch web site
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->get(\*(Aqmojolicio.us/perldoc\*(Aq);
\&
\&  # Extract title
\&  print \*(AqTitle: \*(Aq, $tx\->res\->dom\->at(\*(Aqhead > title\*(Aq)\->text, "\en";
\&
\&  # Extract headers
\&  $tx\->res\->dom(\*(Aqh1, h2, h3\*(Aq)\->each(sub {
\&    print \*(AqHeader: \*(Aq, shift\->all_text, "\en";
\&  });
.Ve
.PP
Especially for unit testing your Mojolicious applications this can be a
very powerful tool.
.SS "\s-1JSON\s0 Web Services"
.IX Subsection "JSON Web Services"
Most web services these days are based on the \s-1JSON\s0 data-interchange format.
That's why Mojolicious comes with the possibly fastest pure-Perl
implementation Mojo::JSON built right in.
.PP
.Vb 2
\&  # Fresh user agent
\&  my $ua = Mojo::UserAgent\->new;
\&
\&  # Fetch the latest news about Mojolicious from Twitter
\&  my $search = \*(Aqhttp://search.twitter.com/search.json?q=Mojolicious\*(Aq;
\&  for $tweet (@{$ua\->get($search)\->res\->json\->{results}}) {
\&
\&    # Tweet text
\&    my $text = $tweet\->{text};
\&
\&    # Twitter user
\&    my $user = $tweet\->{from_user};
\&
\&    # Show both
\&    my $result = "$text \-\-$user\en\en";
\&    utf8::encode $result;
\&    print $result;
\&  }
.Ve
.SS "Basic Authentication"
.IX Subsection "Basic Authentication"
You can just add username and password to the \s-1URL\s0.
.PP
.Vb 2
\&  my $ua = Mojo::UserAgent\->new;
\&  print $ua\->get(\*(Aqhttps://sri:secret@mojolicio.us/hideout\*(Aq)\->res\->body;
.Ve
.SS "Decorating Followup Requests"
.IX Subsection "Decorating Followup Requests"
Mojo::UserAgent can automatically follow redirects, the \f(CW\*(C`on_start\*(C'\fR
callback allows you direct access to each transaction right after they have
been initialized and before a connection gets associated with them.
.PP
.Vb 2
\&  # User agent following up to 10 redirects
\&  my $ua = Mojo::UserAgent\->new(max_redirects => 10);
\&
\&  # Add a witty header to every request
\&  $ua\->on_start(sub {
\&    my $tx = pop;
\&    $tx\->req\->headers\->header(\*(AqX\-Bender\*(Aq => \*(AqBite my shiny metal ass!\*(Aq);
\&    print \*(AqRequest: \*(Aq, $tx\->req\->url\->clone\->to_abs, "\en";
\&  });
\&
\&  # Request that will most likely get redirected
\&  print \*(AqTitle: \*(Aq,
\&    $ua\->get(\*(Aqgoogle.com\*(Aq)\->res\->dom\->at(\*(Aqhead > title\*(Aq)\->text, "\en";
.Ve
.PP
This even works for proxy \f(CW\*(C`CONNECT\*(C'\fR requests.
.SS "Streaming Response"
.IX Subsection "Streaming Response"
Receiving a streaming response can be really tricky in most \s-1HTTP\s0 clients,
Mojo::UserAgent makes it actually easy.
.PP
.Vb 4
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttp://mojolicio.us\*(Aq);
\&  $tx\->res\->body(sub { print $_[1] });
\&  $ua\->start($tx);
.Ve
.PP
The \f(CW\*(C`body\*(C'\fR callback will be called for every chunk of data that is received,
even \f(CW\*(C`chunked\*(C'\fR encoding will be handled transparently if necessary.
.SS "Streaming Request"
.IX Subsection "Streaming Request"
Sending a streaming request is almost just as easy.
.PP
.Vb 10
\&  my $ua      = Mojo::UserAgent\->new;
\&  my $tx      = $ua\->build_tx(GET => \*(Aqhttp://mojolicio.us\*(Aq);
\&  my $content = \*(AqHello world!\*(Aq;
\&  $tx\->req\->headers\->content_length(length $content);
\&  my $drain;
\&  $drain = sub {
\&    my $req   = shift;
\&    my $chunk = substr $content, 0, 1, \*(Aq\*(Aq;
\&    $drain    = undef unless length $content;
\&    $req\->write($chunk, $drain);
\&  };
\&  $drain\->($tx\->req);
\&  $ua\->start($tx);
.Ve
.PP
The drain callback passed to \f(CW\*(C`write\*(C'\fR will be invoked whenever the entire
previous chunk has been written to the kernel send buffer.
.SS "Large File Downloads"
.IX Subsection "Large File Downloads"
When downloading large files with Mojo::UserAgent you don't have to worry
about memory usage at all, because it will automatically stream everything
above \f(CW\*(C`250KB\*(C'\fR into a temporary file.
.PP
.Vb 4
\&  # Lets fetch the latest Mojolicious tarball
\&  my $ua = Mojo::UserAgent\->new(max_redirects => 5);
\&  my $tx = $ua\->get(\*(Aqlatest.mojolicio.us\*(Aq);
\&  $tx\->res\->content\->asset\->move_to(\*(Aqmojo.tar.gz\*(Aq);
.Ve
.PP
To protect you from excessively large files there is also a global limit of
\&\f(CW\*(C`5MB\*(C'\fR by default, which you can tweak with the \f(CW\*(C`MOJO_MAX_MESSAGE_SIZE\*(C'\fR
environment variable.
.PP
.Vb 2
\&  # Increase limit to 1GB
\&  $ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;
.Ve
.SS "Large File Upload"
.IX Subsection "Large File Upload"
Uploading a large file is even easier.
.PP
.Vb 4
\&  # Upload file via POST and "multipart/form\-data"
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->post_form(\*(Aqmojolicio.us/upload\*(Aq,
\&    {image => {file => \*(Aq/Users/sri/hello.png\*(Aq}});
.Ve
.PP
And once again you don't have to worry about memory usage, all data will be
streamed directly from the file.
.PP
.Vb 6
\&  # Upload file via PUT
\&  my $ua     = Mojo::UserAgent\->new;
\&  my $asset  = Mojo::Asset::File\->new(path => \*(Aq/Users/sri/hello.png\*(Aq);
\&  my $tx     = $ua\->build_tx(PUT => \*(Aqmojolicio.us/upload\*(Aq);
\&  $tx\->req\->content\->asset($asset);
\&  $ua\->start($tx);
.Ve
.SS "Non-Blocking"
.IX Subsection "Non-Blocking"
Mojo::UserAgent has been designed from the ground up to be non-blocking,
the whole blocking \s-1API\s0 is just a simple convenience wrapper.
Especially for high latency tasks like web crawling this can be extremely
useful, because you can keep many parallel connections active at the same
time.
.PP
.Vb 2
\&  # FIFO queue
\&  my @urls = qw/google.com/;
\&
\&  # User agent following up to 5 redirects
\&  my $ua = Mojo::UserAgent\->new(max_redirects => 5);
\&
\&  # Crawler
\&  my $crawl;
\&  $crawl = sub {
\&    my $id = shift;
\&
\&    # Dequeue or wait for more URLs
\&    return Mojo::IOLoop\->timer(2 => sub { $crawl\->($id) })
\&      unless my $url = shift @urls;
\&
\&    # Fetch non\-blocking just by adding a callback
\&    $ua\->get($url => sub {
\&      my $tx = pop;
\&
\&      # Extract URLs
\&      print "[$id] $url\en";
\&      $tx\->res\->dom(\*(Aqa[href]\*(Aq)\->each(sub {
\&        my $e = shift;
\&
\&        # Build absolute URL
\&        my $url = Mojo::URL\->new($e\->attrs(\*(Aqhref\*(Aq))\->to_abs($tx\->req\->url);
\&        print " \-> $url\en";
\&
\&        # Enqueue
\&        push @urls, $url;
\&      });
\&
\&      # Next
\&      $crawl\->($id);
\&    });
\&  };
\&
\&  # Start a bunch of parallel crawlers sharing the same user agent
\&  $crawl\->($_) for 1 .. 3;
\&
\&  # Start event loop
\&  Mojo::IOLoop\->start;
.Ve
.PP
You can take full control of the Mojo::IOLoop event loop.
.SS "Command Line"
.IX Subsection "Command Line"
Don't you hate checking huge \s-1HTML\s0 files from the command line?
Thanks to the \f(CW\*(C`mojo get\*(C'\fR command that is about to change.
You can just pick the parts that actually matter with the \s-1CSS3\s0 selectors from
Mojo::DOM.
.PP
.Vb 2
\&  % mojo get http://mojolicio.us \*(Aqhead > title\*(Aq
\&  ...
.Ve
.PP
How about a list of all id attributes?
.PP
.Vb 2
\&  % mojo get http://mojolicio.us \*(Aq*\*(Aq attr id
\&  ...
.Ve
.PP
Or the text content of all header tags?
.PP
.Vb 2
\&  % mojo get http://mojolicio.us \*(Aqh1, h2, h3\*(Aq text
\&  ...
.Ve
.PP
Maybe just the text of the third header?
.PP
.Vb 2
\&  % mojo get http://mojolicio.us \*(Aqh1, h2, h3\*(Aq 3 text
\&  ...
.Ve
.PP
You can also extract all text from nested child elements.
.PP
.Vb 2
\&  % mojo get http://mojolicio.us \*(Aq#mojobar\*(Aq all
\&  ...
.Ve
.PP
The request can be customized as well.
.PP
.Vb 4
\&  % mojo get \-\-method post \-\-content \*(AqHello!\*(Aq http://mojolicio.us
\&  ...
\&  % mojo get \-\-header \*(AqX\-Bender: Bite my shiny metal ass!\*(Aq http://google.com
\&  ...
.Ve
.PP
You can follow redirects and view the headers for all messages.
.PP
.Vb 2
\&  % mojo get \-\-redirect \-\-verbose http://reddit.com \*(Aqhead > title\*(Aq
\&  ...
.Ve
.PP
This can be an invaluable tool for testing your applications.
.PP
.Vb 2
\&  % ./myapp.pl get /welcome \*(Aqhead > title\*(Aq
\&  ...
.Ve
.SH "HACKS"
.IX Header "HACKS"
Fun hacks you might not use very often but that might come in handy some day.
.SS "Making Your Application Installable"
.IX Subsection "Making Your Application Installable"
Ever thought about releasing your Mojolicious application to \s-1CPAN\s0?
It's actually much easier than you might think.
.PP
.Vb 5
\&  % mojo generate app
\&  ...
\&  % cd my_mojolicious_app
\&  % mv public lib/MyMojoliciousApp/
\&  % mv templates lib/MyMojoliciousApp/
.Ve
.PP
The trick is to move the \f(CW\*(C`public\*(C'\fR and \f(CW\*(C`templates\*(C'\fR directories so they can
get automatically installed with the modules.
.PP
.Vb 2
\&  package MyMojoliciousApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  use File::Basename \*(Aqdirname\*(Aq;
\&  use File::Spec;
\&
\&  # Every CPAN module needs a version
\&  our $VERSION = \*(Aq1.0\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Switch to installable home directory
\&    $self\->home\->parse(
\&      File::Spec\->catdir(dirname(_\|_FILE_\|_), \*(AqMyMojoliciousApp\*(Aq));
\&
\&    # Switch to installable "public" directory
\&    $self\->static\->root($self\->home\->rel_dir(\*(Aqpublic\*(Aq));
\&
\&    # Switch to installable "templates" directory
\&    $self\->renderer\->root($self\->home\->rel_dir(\*(Aqtemplates\*(Aq));
\&
\&    $self\->plugin(\*(Aqpod_renderer\*(Aq);
\&
\&    my $r = $self\->routes;
\&    $r\->route(\*(Aq/welcome\*(Aq)\->to(\*(Aqexample#welcome\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Thats really everything, now you can package your application like any other
\&\s-1CPAN\s0 module.
.PP
.Vb 10
\&  % ./script/my_mojolicious_app generate makefile
\&  ...
\&  % perl Makefile.PL
\&  ...
\&  % make test
\&  ...
\&  % make manifest
\&  ...
\&  % make dist
\&  ...
.Ve
.SS "Hello World"
.IX Subsection "Hello World"
If every byte matters this is the smallest \f(CW\*(C`Hello World\*(C'\fR application you can
write with Mojolicious::Lite.
.PP
.Vb 3
\&  use Mojolicious::Lite;
\&  any {text => \*(AqHello World!\*(Aq};
\&  app\->start;
.Ve
.PP
It works because all routes without a pattern default to \f(CW\*(C`/\*(C'\fR and automatic
rendering kicks in even if no actual code gets executed by the router.
The renderer just picks up the \f(CW\*(C`text\*(C'\fR value from the stash and generates a
response.
.SS "Hello World Oneliner"
.IX Subsection "Hello World Oneliner"
The \f(CW\*(C`Hello World\*(C'\fR example above can get even a little bit shorter in an
ojo oneliner.
.PP
.Vb 1
\&  perl \-Mojo \-e\*(Aqa({text => "Hello World!"})\->start\*(Aq daemon
.Ve
.PP
And you can use all the commands from Mojolicious::Commands.
.PP
.Vb 1
\&  perl \-Mojo \-e\*(Aqa({text => "Hello World!"})\->start\*(Aq get \-v /
.Ve
.SS "Keeping Mojolicious Up-To-Date"
.IX Subsection "Keeping Mojolicious Up-To-Date"
This tasty oneliner will keep your Mojolicious as fresh as possible.
.PP
.Vb 1
\&  sudo sh \-c "curl \-L cpanmin.us | perl \- http://latest.mojolicio.us"
.Ve
.SS "jQuery (Content Distribution Network)"
.IX Subsection "jQuery (Content Distribution Network)"
These days Mojolicious ships with a bundled version of jQuery, which you
can easily use as a fallback for applications that might be used offline from
time to time.
.PP
.Vb 10
\&  <%= javascript
\&    \*(Aqhttp://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js\*(Aq %>
\&  <%= javascript begin %>
\&    if (typeof jQuery == \*(Aqundefined\*(Aq) {
\&      var e = document.createElement(\*(Aqscript\*(Aq);
\&      e.src = \*(Aq/js/jquery.js\*(Aq;
\&      e.type = \*(Aqtext/javascript\*(Aq;
\&      document.getElementsByTagName("head")[0].appendChild(e);
\&    }
\&  <% end %>
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
