.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::IOLoop 3pm"
.TH Mojo::IOLoop 3pm "2011-05-01" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::IOLoop \- Minimalistic Reactor For Async TCP Clients And Servers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::IOLoop;
\&
\&  # Listen on port 3000
\&  Mojo::IOLoop\->listen(
\&    port => 3000,
\&    on_read => sub {
\&      my ($self, $id, $chunk) = @_;
\&
\&      # Process input
\&      print $chunk;
\&
\&      # Got some data, time to write
\&      $self\->write($id, \*(AqHTTP/1.1 200 OK\*(Aq);
\&    }
\&  );
\&
\&  # Connect to port 3000 with TLS activated
\&  my $id = Mojo::IOLoop\->connect(
\&    address => \*(Aqlocalhost\*(Aq,
\&    port => 3000,
\&    tls => 1,
\&    on_connect => sub {
\&      my ($self, $id) = @_;
\&
\&      # Write request
\&      $self\->write($id, "GET / HTTP/1.1\er\en\er\en");
\&    },
\&    on_read => sub {
\&      my ($self, $id, $chunk) = @_;
\&
\&      # Process input
\&      print $chunk;
\&    }
\&  );
\&
\&  # Add a timer
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $self = shift;
\&    $self\->drop($id);
\&  });
\&
\&  # Start and stop loop
\&  Mojo::IOLoop\->start;
\&  Mojo::IOLoop\->stop;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::IOLoop is a very minimalistic reactor that has been reduced to the
absolute minimal feature set required to build solid and scalable async \s-1TCP\s0
clients and servers.
.PP
Optional modules IO::KQueue, IO::Epoll, IO::Socket::IP and
IO::Socket::SSL are supported transparently and used if installed.
.PP
A \s-1TLS\s0 certificate and key are also built right in to make writing test
servers as easy as possible.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::IOLoop implements the following attributes.
.ie n .SS """accept_timeout"""
.el .SS "\f(CWaccept_timeout\fP"
.IX Subsection "accept_timeout"
.Vb 2
\&  my $timeout = $loop\->accept_timeout;
\&  $loop       = $loop\->accept_timeout(5);
.Ve
.PP
Maximum time in seconds a connection can take to be accepted before being
dropped, defaults to \f(CW3\fR.
.ie n .SS """connect_timeout"""
.el .SS "\f(CWconnect_timeout\fP"
.IX Subsection "connect_timeout"
.Vb 2
\&  my $timeout = $loop\->connect_timeout;
\&  $loop       = $loop\->connect_timeout(5);
.Ve
.PP
Maximum time in seconds a conenction can take to be connected before being
dropped, defaults to \f(CW3\fR.
.ie n .SS """dns_timeout"""
.el .SS "\f(CWdns_timeout\fP"
.IX Subsection "dns_timeout"
.Vb 2
\&  my $timeout = $loop\->dns_timeout;
\&  $loop       = $loop\->dns_timeout(5);
.Ve
.PP
Maximum time in seconds a \f(CW\*(C`DNS\*(C'\fR lookup can take, defaults to \f(CW3\fR.
Note that this attribute is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """max_accepts"""
.el .SS "\f(CWmax_accepts\fP"
.IX Subsection "max_accepts"
.Vb 2
\&  my $max = $loop\->max_accepts;
\&  $loop   = $loop\->max_accepts(1000);
.Ve
.PP
The maximum number of connections this loop is allowed to accept before
shutting down gracefully without interrupting existing connections, defaults
to \f(CW0\fR.
Setting the value to \f(CW0\fR will allow this loop to accept new connections
infinitely.
Note that this attribute is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """max_connections"""
.el .SS "\f(CWmax_connections\fP"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $loop\->max_connections;
\&  $loop   = $loop\->max_connections(1000);
.Ve
.PP
The maximum number of parallel connections this loop is allowed to handle
before stopping to accept new incoming connections, defaults to \f(CW1000\fR.
Setting the value to \f(CW0\fR will make this loop stop accepting new connections
and allow it to shutdown gracefully without interrupting existing
connections.
.ie n .SS """on_lock"""
.el .SS "\f(CWon_lock\fP"
.IX Subsection "on_lock"
.Vb 2
\&  my $cb = $loop\->on_lock;
\&  $loop  = $loop\->on_lock(sub {...});
.Ve
.PP
A locking callback that decides if this loop is allowed to accept new
incoming connections, used to sync multiple server processes.
The callback should return true or false.
Note that exceptions in this callback are not captured.
.PP
.Vb 2
\&  $loop\->on_lock(sub {
\&    my ($loop, $blocking) = @_;
\&
\&    # Got the lock, listen for new connections
\&    return 1;
\&  });
.Ve
.ie n .SS """on_unlock"""
.el .SS "\f(CWon_unlock\fP"
.IX Subsection "on_unlock"
.Vb 2
\&  my $cb = $loop\->on_unlock;
\&  $loop  = $loop\->on_unlock(sub {...});
.Ve
.PP
A callback to free the accept lock, used to sync multiple server processes.
Note that exceptions in this callback are not captured.
.ie n .SS """timeout"""
.el .SS "\f(CWtimeout\fP"
.IX Subsection "timeout"
.Vb 2
\&  my $timeout = $loop\->timeout;
\&  $loop       = $loop\->timeout(5);
.Ve
.PP
Maximum time in seconds our loop waits for new events to happen, defaults to
\&\f(CW0.025\fR.
Note that a value of \f(CW0\fR would make the loop non-blocking.
.SH "METHODS"
.IX Header "METHODS"
Mojo::IOLoop inherits all methods from Mojo::Base and implements the
following new ones.
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
.Vb 1
\&  my $loop = Mojo::IOLoop\->new;
.Ve
.PP
Construct a new Mojo::IOLoop object.
Multiple of these will block each other, so use \f(CW\*(C`singleton\*(C'\fR instead if
possible.
.ie n .SS """connect"""
.el .SS "\f(CWconnect\fP"
.IX Subsection "connect"
.Vb 8
\&  my $id = Mojo::IOLoop\->connect(
\&    address => \*(Aq127.0.0.1\*(Aq,
\&    port    => 3000
\&  );
\&  my $id = $loop\->connect(
\&    address => \*(Aq127.0.0.1\*(Aq,
\&    port    => 3000
\&  );
.Ve
.PP
Open a \s-1TCP\s0 connection to a remote host.
Note that \s-1TLS\s0 support depends on IO::Socket::SSL and IPv6 support on
IO::Socket::IP.
.PP
These options are currently available.
.ie n .IP """address""" 2
.el .IP "\f(CWaddress\fR" 2
.IX Item "address"
Address or host name of the peer to connect to.
.ie n .IP """handle""" 2
.el .IP "\f(CWhandle\fR" 2
.IX Item "handle"
Use an already prepared handle.
.ie n .IP """on_connect""" 2
.el .IP "\f(CWon_connect\fR" 2
.IX Item "on_connect"
Callback to be invoked once the connection is established.
.ie n .IP """on_close""" 2
.el .IP "\f(CWon_close\fR" 2
.IX Item "on_close"
Callback to be invoked if the connection gets closed.
.ie n .IP """on_error""" 2
.el .IP "\f(CWon_error\fR" 2
.IX Item "on_error"
Callback to be invoked if an error event happens on the connection.
.ie n .IP """on_read""" 2
.el .IP "\f(CWon_read\fR" 2
.IX Item "on_read"
Callback to be invoked if new data arrives on the connection.
.ie n .IP """port""" 2
.el .IP "\f(CWport\fR" 2
.IX Item "port"
Port to connect to.
.ie n .IP """proto""" 2
.el .IP "\f(CWproto\fR" 2
.IX Item "proto"
Protocol to use, defaults to \f(CW\*(C`tcp\*(C'\fR.
.ie n .IP """tls""" 2
.el .IP "\f(CWtls\fR" 2
.IX Item "tls"
Enable \s-1TLS\s0.
.ie n .IP """tls_cert""" 2
.el .IP "\f(CWtls_cert\fR" 2
.IX Item "tls_cert"
Path to the \s-1TLS\s0 certificate file.
.ie n .IP """tls_key""" 2
.el .IP "\f(CWtls_key\fR" 2
.IX Item "tls_key"
Path to the \s-1TLS\s0 key file.
.ie n .SS """connection_timeout"""
.el .SS "\f(CWconnection_timeout\fP"
.IX Subsection "connection_timeout"
.Vb 2
\&  my $timeout = $loop\->connection_timeout($id);
\&  $loop       = $loop\->connection_timeout($id => 45);
.Ve
.PP
Maximum amount of time in seconds a connection can be inactive before being
dropped.
.ie n .SS """dns_servers"""
.el .SS "\f(CWdns_servers\fP"
.IX Subsection "dns_servers"
.Vb 4
\&  my @all     = Mojo::IOLoop\->dns_servers;
\&  my @all     = $loop\->dns_servers;
\&  my $current = $loop\->dns_servers;
\&  $loop       = $loop\->dns_servers(\*(Aq8.8.8.8\*(Aq, \*(Aq8.8.4.4\*(Aq);
.Ve
.PP
\&\s-1IP\s0 addresses of \f(CW\*(C`DNS\*(C'\fR servers used for non-blocking lookups, defaults to the
value of \f(CW\*(C`MOJO_DNS_SERVER\*(C'\fR, auto detection, \f(CW8.8.8.8\fR or \f(CW8.8.4.4\fR.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """drop"""
.el .SS "\f(CWdrop\fP"
.IX Subsection "drop"
.Vb 2
\&  $loop = Mojo::IOLoop\->drop($id)
\&  $loop = $loop\->drop($id);
.Ve
.PP
Drop anything with an id.
Connections will be dropped gracefully by allowing them to finish writing all
data in its write buffer.
.ie n .SS """generate_port"""
.el .SS "\f(CWgenerate_port\fP"
.IX Subsection "generate_port"
.Vb 2
\&  my $port = Mojo::IOLoop\->generate_port;
\&  my $port = $loop\->generate_port;
.Ve
.PP
Find a free \s-1TCP\s0 port, this is a utility function primarily used for tests.
.ie n .SS """handle"""
.el .SS "\f(CWhandle\fP"
.IX Subsection "handle"
.Vb 1
\&  my $handle = $loop\->handle($id);
.Ve
.PP
Get handle for id.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """idle"""
.el .SS "\f(CWidle\fP"
.IX Subsection "idle"
.Vb 2
\&  my $id = Mojo::IOLoop\->idle(sub {...});
\&  my $id = $loop\->idle(sub {...});
.Ve
.PP
Callback to be invoked on every reactor tick if no other events occurred.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """is_running"""
.el .SS "\f(CWis_running\fP"
.IX Subsection "is_running"
.Vb 2
\&  my $running = Mojo::IOLoop\->is_running;
\&  my $running = $loop\->is_running;
.Ve
.PP
Check if loop is running.
.PP
.Vb 1
\&  exit unless Mojo::IOLoop\->is_running;
.Ve
.ie n .SS """listen"""
.el .SS "\f(CWlisten\fP"
.IX Subsection "listen"
.Vb 10
\&  my $id = Mojo::IOLoop\->listen(port => 3000);
\&  my $id = $loop\->listen(port => 3000);
\&  my $id = $loop\->listen({port => 3000});
\&  my $id = $loop\->listen(file => \*(Aq/foo/myapp.sock\*(Aq);
\&  my $id = $loop\->listen(
\&    port     => 443,
\&    tls      => 1,
\&    tls_cert => \*(Aq/foo/server.cert\*(Aq,
\&    tls_key  => \*(Aq/foo/server.key\*(Aq
\&  );
.Ve
.PP
Create a new listen socket.
Note that \s-1TLS\s0 support depends on IO::Socket::SSL and IPv6 support on
IO::Socket::IP.
.PP
These options are currently available.
.ie n .IP """address""" 2
.el .IP "\f(CWaddress\fR" 2
.IX Item "address"
Local address to listen on, defaults to all.
.ie n .IP """backlog""" 2
.el .IP "\f(CWbacklog\fR" 2
.IX Item "backlog"
Maximum backlog size, defaults to \f(CW\*(C`SOMAXCONN\*(C'\fR.
.ie n .IP """file""" 2
.el .IP "\f(CWfile\fR" 2
.IX Item "file"
A unix domain socket to listen on.
.ie n .IP """on_accept""" 2
.el .IP "\f(CWon_accept\fR" 2
.IX Item "on_accept"
Callback to invoke for each accepted connection.
.ie n .IP """on_close""" 2
.el .IP "\f(CWon_close\fR" 2
.IX Item "on_close"
Callback to be invoked if the connection gets closed.
.ie n .IP """on_error""" 2
.el .IP "\f(CWon_error\fR" 2
.IX Item "on_error"
Callback to be invoked if an error event happens on the connection.
.ie n .IP """on_read""" 2
.el .IP "\f(CWon_read\fR" 2
.IX Item "on_read"
Callback to be invoked if new data arrives on the connection.
.ie n .IP """port""" 2
.el .IP "\f(CWport\fR" 2
.IX Item "port"
Port to listen on.
.ie n .IP """tls""" 2
.el .IP "\f(CWtls\fR" 2
.IX Item "tls"
Enable \s-1TLS\s0.
.ie n .IP """tls_cert""" 2
.el .IP "\f(CWtls_cert\fR" 2
.IX Item "tls_cert"
Path to the \s-1TLS\s0 cert file, defaulting to a built in test certificate.
.ie n .IP """tls_key""" 2
.el .IP "\f(CWtls_key\fR" 2
.IX Item "tls_key"
Path to the \s-1TLS\s0 key file, defaulting to a built in test key.
.ie n .IP """tls_ca""" 2
.el .IP "\f(CWtls_ca\fR" 2
.IX Item "tls_ca"
Path to \s-1TLS\s0 certificate authority file or directory.
.ie n .SS """local_info"""
.el .SS "\f(CWlocal_info\fP"
.IX Subsection "local_info"
.Vb 1
\&  my $info = $loop\->local_info($id);
.Ve
.PP
Get local information about a connection.
.PP
.Vb 1
\&  my $address = $info\->{address};
.Ve
.PP
These values are to be expected in the returned hash reference.
.ie n .IP """address""" 2
.el .IP "\f(CWaddress\fR" 2
.IX Item "address"
The local address.
.ie n .IP """port""" 2
.el .IP "\f(CWport\fR" 2
.IX Item "port"
The local port.
.ie n .SS """lookup"""
.el .SS "\f(CWlookup\fP"
.IX Subsection "lookup"
.Vb 2
\&  $loop = Mojo::IOLoop\->lookup(\*(Aqmojolicio.us\*(Aq => sub {...});
\&  $loop = $loop\->lookup(\*(Aqmojolicio.us\*(Aq => sub {...});
.Ve
.PP
Lookup \f(CW\*(C`IPv4\*(C'\fR or \f(CW\*(C`IPv6\*(C'\fR address for domain.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.PP
.Vb 4
\&  $loop\->lookup(\*(Aqmojolicio.us\*(Aq => sub {
\&    my ($loop, $address) = @_;
\&    print "Address: $address\en";
\&  });
.Ve
.ie n .SS """on_close"""
.el .SS "\f(CWon_close\fP"
.IX Subsection "on_close"
.Vb 1
\&  $loop = $loop\->on_close($id => sub {...});
.Ve
.PP
Callback to be invoked if the connection gets closed.
.ie n .SS """on_error"""
.el .SS "\f(CWon_error\fP"
.IX Subsection "on_error"
.Vb 1
\&  $loop = $loop\->on_error($id => sub {...});
.Ve
.PP
Callback to be invoked if an error event happens on the connection.
.ie n .SS """on_read"""
.el .SS "\f(CWon_read\fP"
.IX Subsection "on_read"
.Vb 1
\&  $loop = $loop\->on_read($id => sub {...});
.Ve
.PP
Callback to be invoked if new data arrives on the connection.
.PP
.Vb 2
\&  $loop\->on_read($id => sub {
\&    my ($loop, $id, $chunk) = @_;
\&
\&    # Process chunk
\&  });
.Ve
.ie n .SS """one_tick"""
.el .SS "\f(CWone_tick\fP"
.IX Subsection "one_tick"
.Vb 3
\&  $loop\->one_tick;
\&  $loop\->one_tick(\*(Aq0.25\*(Aq);
\&  $loop\->one_tick(0);
.Ve
.PP
Run reactor for exactly one tick.
.ie n .SS """recurring"""
.el .SS "\f(CWrecurring\fP"
.IX Subsection "recurring"
.Vb 2
\&  my $id = Mojo::IOLoop\->recurring(0 => sub {...});
\&  my $id = $loop\->recurring(3 => sub {...});
.Ve
.PP
Callback to be invoked on every reactor tick, this for example allows you to
run multiple reactors next to each other.
.PP
.Vb 2
\&  my $loop2 = Mojo::IOLoop\->new(timeout => 0);
\&  Mojo::IOLoop\->recurring(0 => sub { $loop2\->one_tick });
.Ve
.PP
Note that the loop timeout can be changed dynamically at any time to adjust
responsiveness.
.ie n .SS """remote_info"""
.el .SS "\f(CWremote_info\fP"
.IX Subsection "remote_info"
.Vb 1
\&  my $info = $loop\->remote_info($id);
.Ve
.PP
Get remote information about a connection.
.PP
.Vb 1
\&  my $address = $info\->{address};
.Ve
.PP
These values are to be expected in the returned hash reference.
.ie n .IP """address""" 2
.el .IP "\f(CWaddress\fR" 2
.IX Item "address"
The remote address.
.ie n .IP """port""" 2
.el .IP "\f(CWport\fR" 2
.IX Item "port"
The remote port.
.ie n .SS """resolve"""
.el .SS "\f(CWresolve\fP"
.IX Subsection "resolve"
.Vb 2
\&  $loop = Mojo::IOLoop\->resolve(\*(Aqmojolicio.us\*(Aq, \*(AqA\*(Aq, sub {...});
\&  $loop = $loop\->resolve(\*(Aqmojolicio.us\*(Aq, \*(AqA\*(Aq, sub {...});
.Ve
.PP
Resolve domain into \f(CW\*(C`A\*(C'\fR, \f(CW\*(C`AAAA\*(C'\fR, \f(CW\*(C`CNAME\*(C'\fR, \f(CW\*(C`MX\*(C'\fR, \f(CW\*(C`NS\*(C'\fR, \f(CW\*(C`PTR\*(C'\fR or \f(CW\*(C`TXT\*(C'\fR
records, \f(CW\*(C`*\*(C'\fR will query for all at once.
Since this is a \*(L"stub resolver\*(R" it depends on a recursive name server for \s-1DNS\s0
resolution.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """singleton"""
.el .SS "\f(CWsingleton\fP"
.IX Subsection "singleton"
.Vb 1
\&  my $loop = Mojo::IOLoop\->singleton;
.Ve
.PP
The global loop object, used to access a single shared loop instance from
everywhere inside the process.
Many methods also allow you to take shortcuts when using the Mojo::IOLoop
singleton.
.PP
.Vb 2
\&  Mojo::IOLoop\->timer(2 => sub { Mojo::IOLoop\->stop });
\&  Mojo::IOLoop\->start;
.Ve
.ie n .SS """start"""
.el .SS "\f(CWstart\fP"
.IX Subsection "start"
.Vb 2
\&  Mojo::IOLoop\->start;
\&  $loop\->start;
.Ve
.PP
Start the loop, this will block until \f(CW\*(C`stop\*(C'\fR is called or return immediately
if the loop is already running.
.ie n .SS """start_tls"""
.el .SS "\f(CWstart_tls\fP"
.IX Subsection "start_tls"
.Vb 1
\&  my $id = $loop\->start_tls($id);
.Ve
.PP
Start new \s-1TLS\s0 connection inside old connection.
Note that \s-1TLS\s0 support depends on IO::Socket::SSL.
.ie n .SS """stop"""
.el .SS "\f(CWstop\fP"
.IX Subsection "stop"
.Vb 2
\&  Mojo::IOLoop\->stop;
\&  $loop\->stop;
.Ve
.PP
Stop the loop immediately, this will not interrupt any existing connections
and the loop can be restarted by running \f(CW\*(C`start\*(C'\fR again.
.ie n .SS """test"""
.el .SS "\f(CWtest\fP"
.IX Subsection "test"
.Vb 1
\&  my $success = $loop\->test($id);
.Ve
.PP
Test for errors and garbage bytes on the connection.
Note that this method is \s-1EXPERIMENTAL\s0 and might change without warning!
.ie n .SS """timer"""
.el .SS "\f(CWtimer\fP"
.IX Subsection "timer"
.Vb 3
\&  my $id = Mojo::IOLoop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(0.25 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of seconds.
.ie n .SS """write"""
.el .SS "\f(CWwrite\fP"
.IX Subsection "write"
.Vb 2
\&  $loop\->write($id => \*(AqHello!\*(Aq);
\&  $loop\->write($id => \*(AqHello!\*(Aq, sub {...});
.Ve
.PP
Write data to connection, the optional drain callback will be invoked once
all data has been written.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
